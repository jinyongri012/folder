# ソフトウェア開発仕様書管理ガイドライン

## 1. 基本方針

### 1.1 「コード = 仕様書」の原則
- **コードの可読性を最優先** - コード自体が仕様として機能する
- **ドキュメントの二重管理を排除** - コードと別文書の同期作業を最小化
- **変更履歴の一元管理** - Gitでコードと仕様変更を同時追跡

### 1.2 管理対象
- ソースコード
- 設定ファイル
- テストコード
- 自動生成可能なドキュメント

---

## 2. コード管理要件

### 2.1 命名規則
| 対象 | 規則 | 理由 |
|------|------|------|
| **変数・関数名** | 意図が明確な名前を使用 | コードの自己文書化 |
| **クラス名** | 責務を表す名詞 | 設計意図の明確化 |
| **ファイル名** | 機能を表す名前 | 構造の理解促進 |

### 2.2 コード構造
```
必須要素：
□ 明確なレイヤー分離（プレゼンテーション/ビジネス/データ）
□ 単一責任の原則に従った関数設計
□ 依存関係の明示化
□ エラーハンドリングの統一
```

### 2.3 コメント記載基準
```
記載すべき内容：
• WHY - なぜこの実装なのか（ビジネスルール・制約）
• 複雑なロジックの意図
• 外部仕様との関連
• TODOと技術的負債

記載不要な内容：
• WHAT - 何をしているか（コードで明白な内容）
• 単純な処理の説明
```

---

## 3. 仕様情報の記載場所

### 3.1 優先順位
```
1. コード内（実装・型定義・定数）
2. コメント（JSDoc・インラインコメント）
3. テストコード（振る舞いの仕様）
4. README.md（概要・セットアップ）
5. 外部ドキュメント（必要最小限）
```

### 3.2 記載内容マトリクス

| 情報種別 | 記載場所 | 形式 |
|---------|---------|------|
| **データ形式** | 型定義・インターフェース | TypeScript/JSDoc |
| **ビジネスルール** | 実装コード内 | 条件分岐・バリデーション |
| **API仕様** | コード内アノテーション | OpenAPI/JSDoc |
| **設定項目** | 設定ファイル | JSON/YAML with スキーマ |
| **制約条件** | バリデーションコード | 実装＋エラーメッセージ |
| **使用方法** | README.md | Markdown |

---

## 4. 必須記載項目

### 4.1 システムレベル
```yaml
システム概要:
  目的: 何のためのシステムか
  対象ユーザー: 誰が使うか
  提供価値: どんな問題を解決するか

アーキテクチャ:
  構成: レイヤー構造・コンポーネント関係
  技術スタック: 使用言語・フレームワーク・ライブラリ
  外部連携: API・サービス・データベース

運用要件:
  環境: 開発・テスト・本番
  設定: 環境変数・設定ファイル
  監視: ログ・メトリクス・アラート
```

### 4.2 コンポーネントレベル
```yaml
各モジュール/クラス:
  責務: 単一の明確な役割
  インターフェース: 公開メソッド・パラメータ・戻り値
  依存関係: 必要な他コンポーネント
  制約: 前提条件・事後条件

データ:
  形式: 型・構造・制約
  フロー: 入力元→処理→出力先
  永続化: 保存先・保持期間

エラー:
  種類: エラーカテゴリ
  処理: リトライ・フォールバック・通知
  回復: 自動回復・手動介入
```

---

## 5. 品質保証

### 5.1 コードレビューチェックリスト
```markdown
□ 命名は意図を正確に表現しているか
□ 関数は単一責任を守っているか
□ エラー処理は適切か
□ テストで仕様が表現されているか
□ 重要なビジネスロジックにコメントがあるか
```

### 5.2 自動化可能な検証
```markdown
• 命名規則チェック（Linter）
• コード複雑度測定
• テストカバレッジ
• 依存関係分析
• ドキュメント生成
```

---

## 6. 変更管理

### 6.1 コミットメッセージ
```
形式: <種別>: <変更内容>

種別:
- feat: 機能追加
- fix: バグ修正
- refactor: リファクタリング
- docs: ドキュメント更新
- test: テスト追加・修正

必須情報:
- 変更理由（WHY）
- 影響範囲
- 関連Issue番号
```

### 6.2 変更時の更新対象
```
優先度高:
1. 実装コード
2. テストコード
3. 関連する設定

優先度中:
4. README（影響がある場合）
5. APIドキュメント（自動生成推奨）

優先度低:
6. 外部ドキュメント（最小限）
```

---

## 7. ツール活用

### 7.1 推奨ツール
| 用途 | ツール例 | 目的 |
|------|---------|------|
| **静的解析** | ESLint, SonarQube | コード品質維持 |
| **ドキュメント生成** | JSDoc, TypeDoc | API仕様自動生成 |
| **図生成** | PlantUML, Mermaid | アーキテクチャ可視化 |
| **テスト** | Jest, Mocha | 仕様の実行可能な表現 |

### 7.2 CI/CD統合
```yaml
自動実行タスク:
  - コード品質チェック
  - テスト実行
  - ドキュメント生成
  - 依存関係更新チェック
```

---

## 8. 段階的導入計画

### Phase 1: 基礎整備（1-2週間）
```
□ 命名規則の統一
□ 基本的なコメント追加
□ READMEの整備
```

### Phase 2: 構造化（2-4週間）
```
□ レイヤー分離
□ 責務の明確化
□ エラーハンドリング統一
```

### Phase 3: 自動化（1-2ヶ月）
```
□ Linter導入
□ ドキュメント自動生成
□ CI/CD整備
```

### Phase 4: 最適化（継続的）
```
□ メトリクス測定
□ リファクタリング
□ プロセス改善
```

---

## 9. アンチパターン

### 避けるべき実践
```
❌ コードと乖離した外部仕様書の作成
❌ 実装詳細の過度なコメント
❌ 更新されない設計書の放置
❌ 複雑な命名規則の強制
❌ 過度な抽象化
```

### 推奨される実践
```
✅ シンプルで理解しやすいコード
✅ ビジネスロジックの明確な表現
✅ テストによる仕様の文書化
✅ 自動生成可能なドキュメント
✅ 継続的な改善
```

---

## 10. 成功指標

### 定量的指標
- コードレビュー時間の短縮
- 新規メンバーのオンボーディング期間短縮
- バグ発生率の低下
- ドキュメント更新の自動化率

### 定性的指標
- コードの可読性向上
- チーム内の知識共有促進
- 保守性の向上
- 技術的負債の削減

---

## 付録: テンプレート

### A. モジュールヘッダーテンプレート
```javascript
/**
 * @module ModuleName
 * @description モジュールの目的と責務
 * @requires 依存モジュール
 * @exports 公開インターフェース
 */
```

### B. 関数ドキュメントテンプレート
```javascript
/**
 * 関数の目的（WHY）
 * @param {Type} name - パラメータの意味
 * @returns {Type} 戻り値の意味
 * @throws {Error} エラー条件
 * @example 使用例
 */
```

### C. 設定ファイルテンプレート
```yaml
# 設定項目名
# 説明: 何のための設定か
# 必須: yes/no
# デフォルト: 値
# 例: 
setting_name: value
```

---

*このガイドラインは継続的に改善されます。実践を通じて得られた知見を反映し、チームに最適な形に調整してください。*